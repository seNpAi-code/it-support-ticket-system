-- Drop existing tables if they exist (to start fresh)
drop table if exists public.comments;
drop table if exists public.tickets;
drop table if exists public.profiles;

-- Create profiles table (Using email as ID since we use NextAuth)
create table public.profiles (
  id uuid default gen_random_uuid() primary key,
  email text unique not null,
  role text check (role in ('user', 'admin')) default 'user',
  full_name text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable Row Level Security (RLS)
alter table public.profiles enable row level security;

-- Create tickets table
create table public.tickets (
  id bigint generated by default as identity primary key,
  title text not null,
  description text,
  status text check (status in ('Open', 'In Progress', 'Resolved')) default 'Open',
  priority text check (priority in ('Low', 'Medium', 'High')) default 'Medium',
  created_by_email text not null, -- Store email of creator
  assigned_to_email text, -- Store email of assignee
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.tickets enable row level security;

-- Create comments table
create table public.comments (
  id bigint generated by default as identity primary key,
  ticket_id bigint references public.tickets(id) on delete cascade not null,
  user_email text not null, -- Store email of commenter
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table public.comments enable row level security;

-- Policies
-- Since we are using NextAuth, we will likely handle authorization in the API layer (Server Actions).
-- However, if we use the Supabase Client with a Service Role key in the backend, RLS is bypassed.
-- If we want to use RLS with the Anon key on the client side, we would need to mint a custom JWT.
-- For simplicity and security in this Next.js App Router setup, we will primarily use Server Actions with the Service Role key (or a restricted client) and verify the NextAuth session in code.
-- BUT, to allow the "anon" key to work if needed (e.g. real-time subscriptions), we can set up basic policies.

-- Allow read access to everyone for now (we will filter in the application layer or add policies based on a custom claim later if needed)
create policy "Enable read access for all users" on public.profiles for select using (true);
create policy "Enable read access for all users" on public.tickets for select using (true);
create policy "Enable read access for all users" on public.comments for select using (true);

-- We will handle INSERT/UPDATE via Server Actions which will check the session and use a privileged client or we can add policies if we implement the custom JWT flow.
-- For this iteration, let's assume we rely on Server Actions + NextAuth Session for security.
